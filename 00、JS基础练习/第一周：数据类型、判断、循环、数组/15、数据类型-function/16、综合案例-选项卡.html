<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>15、数据类型-function</title>
 </head>
 <body>
  <div id="boxEle"></div>
  <script type="text/javascript">
  // 15、数据类型-function
  var obj = {name:"chengjin"};

  // 1、function: 函数数据类型、相当于一个方法或者一个功能

	// 定义一个函数的步骤
		/*
		 01、开辟一个新的空间地址：xxxfff111
		 02、把函数体中的js代码当做字符串存到空间里面(一个函数如果只是定义了，并没有执行的庆，这个函数没有任何的意义)

		 03、在把我们的地址给我们的函数名
		*/
		function fn(){
			// 函数体
				/*
					什么是函数：就是一个功能或者一个方法实现的步骤
				*/
				console.log("中国深圳");
		};
		fn(); // 执行这个函数
		// 首符会形成一个息的私有地盘
		// 然后把定义的时候，存在空间的js代码字符串当做js代码执行

		var obj = {name:"呈琛"};

		// 一个约会的计划
			/*
			function 约会(){
				1.准备钱
				2.制定路线(先去长城，欢乐谷，国家大剧院，去梅州东坡酒楼，电影院，把女朋友送回家)
				3.打电话约
			}
			约会();
			"刘诗诗"
			*/


		// 求一个1+1的和
			/*console.log(1+1); // 2*/
		
		// 变量 变量=1 变量+3 变量*5....
			/*var num = 1;
			num+=3
			num*=5;
			console.log(num);

			function sum(){
				var num = 1;
				num+=3
				num*=5;
				console.log(num);
			}
			sum();
			sum();*/

	// 2、js中function的一个特别大的作用(我们把这个方法叫做封装)：将实现一个功能的代码进行封装，以后如果用到了这个功能，代码没有必要在重新的写了，只需要执行这个方法就好了

		/*function sum(){
			var total = 1+1;
			console.log(total);
		}
		sum();
		sum();*/

	// 3、第一次升级：形参的概述(可以理解为一个变量)
		
		/*function sum(num1, num2){
			var total = num1 + num2;
			console.log(total);
		}
		sum(1,1);
		sum(2,2);*/
		
		// 第一次升级：形参的概述(可以理解为一个变量)(也叫多态 就是一个功能的多种形态，通过参数的不同实现不同的的功能)
		
			/*function sum(num1, num2){
				var total = num1 + num2;
				console.log(total);
			}
			sum(100,200);
			sum(2,2);*/
		
		

		// 形参的作用：实现一个功能，发现部分原材料没有，在制定计划的时候我们没有办法获取，我们就把需要的原材料定义在我们的形参上，在执行的计划的时候，把原材料提供了就好了，这就是我们的作用

		// 定义一个形参变量，执行的时候没有传递值，那默认是undefined
		
		/*function sum(num1, num2){
			var total = 0;
			
			// 用typeof 检查形参是否有传递进来值
			if(typeof num1 != "undefined"){
				total += num1
			}
			
			if(typeof num2 != "undefined"){
				total += num2;
			}			
			console.log(total);
		}
		sum(100,200); // 300 
		sum(100);	  // 100*/



	// 3、arguments: 是函数内置接收参数的机制
		  /*
			内置：是天生自带的，不管你是否传递了参数，也不客是否写形参了，arguments一真的存在

			arguments 也是一个类数组(有数字作为索引，索引从0开始代表第几个传递的参数，还有一个length的属性代表传递了多少个参数)

			arguments 获取其中的某一个只能用arguments[索引]，不能用.item()
			callee: arguments.callee代表的就是当前函数的本身
		  */

		  // 任意数求和
		   function fn(){
			   var total = 0;
			   for(var i = 0; i < arguments.length; i++){
					var cur = arguments[i];
					//total += cur;
					cur = Number(cur);
					//if(isNaN(cur) === false){
					if(!isNaN(cur)){
						total += cur;
					}
			   }
			   console.log(total);

				
				//console.dir(arguments);
				//console.log(arguments[0]); // 获得第一个
				//console.log(arguments[1]); // 获得第二个
				
			}
			fn(123,234,"a");
			fn();
			fn(213);
			fn(1,2,3,4,5,6,7,8,9,10);





			function fns(){
			   var total = 0;
			   for(var i = 0; i < arguments.length; i++){
					var cur = arguments[i];
					//total += cur;
					cur = Number(cur);
					//if(isNaN(cur) === false){
					if(!isNaN(cur)){
						total += cur;
					}
			   }
			   console.log(total);

				/*
				console.dir(arguments);
				console.log(arguments[0]); // 获得第
				console.log(arguments[1]); // 获得第
				*/
			}
			fns(123,234,"3");

			 // 函数执行的时候，会形成一个私有的地盘(函数里面定义的变量，在外面不能直接使用)

			 // 闭包：函数执行的时候会形成一个新的私有的作用域，来保护里面的变量不外界的干扰，我们把这种保护机制做闭包

			 function fns(){
			   var total = 0;
			   for(var i = 0; i < arguments.length; i++){
					var cur = arguments[i];
					//total += cur;
					cur = Number(cur);
					//if(isNaN(cur) === false){
					if(!isNaN(cur)){
						total += cur;
					}
			   }
			   // 我在里面想用谁就用 return 谁
			   return total;
			}
			// fns(123,234,"3");
			console.log(fns(123,234,"3")); // 通常不会这么用的
			var total = fns(123,234,"3")   // 把函数执行完成的整体返回值赋值给外面的total这个变量
			total*=3;
			console.log(total);

			var n = fns(100, 200)

			

			// 外面面相用什么，在函数里直接的 return 返回就可以了，函数执行完的整体就是这个值


			// 如果我们没有写 return的话(或者 return)， 默认的返回结果是undefined

			// 在函数体中，return后面的值不会再执行：return的第二个作用，控制函数体中的代码执行到什么指定的位置就结束

			// console.dir() 比 console.log() 在控制台输出的详细一些;


/***********************************************
*上面讲的都是实名函数，除了实名函数还有匿名函数*
************************************************/
	/*
		函数表达式：把一个匿名的定义部当做一个值赋值给一个变量或者一个元素的事件
	
		var fn = function(){
	
		}
		fn();
	
		var oBody = document.getElementById("boxEle");
		oBody.onclick = function(){
			
		}
	*/

	// 自执行函数：定义执行一起完成了
		(function(){
		
		})();
		
		~function(){}();
		!function(){}();
		+function(){}();
		-function(){}();
		

	

  </script>
 </body>
</html>
